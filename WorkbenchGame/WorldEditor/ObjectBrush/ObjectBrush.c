#ifdef WORKBENCH
[WorkbenchToolAttribute(name: "Object Brush", description: "Generate randomized compositions using a brush", shortcut: "B", wbModules: { "WorldEditor" }, awesomeFontCode: 0xF1FC)]
class ObjectBrushTool : WorldEditorTool
{
	protected static const float HECTARE_CONVERSION_FACTOR = 0.0001; // x/10000 (hectare is 100×100m)
	protected static const float MAX_SCALE_THRESHOLD = 1000;

	protected static const float RADIUS_STEP = 1;
	protected static const float RADIUS_MAX = 100;
	protected static const float RADIUS_MIN = 0.1;

	protected static const float STRENGTH_STEP = 1;
	protected static const float STRENGTH_MAX = 500;
	protected static const float STRENGTH_MIN = 0;

	protected static const float STRENGTH_RELATIVE_RADIUS_DISTANCE_TO_CREATE = 1 / 3;

	/*
		Category: OBJECT BRUSH
	*/
	[Attribute("10", UIWidgets.Slider, "Radius of the brush", params: string.Format("%1 %2 %3", RADIUS_MIN, RADIUS_MAX, RADIUS_STEP), category: "Object Brush")]
	protected float m_fRadius;

	[Attribute("10", UIWidgets.Slider, "Strength of the brush (objects per hectare (100×100m))", params: string.Format("%1 %2 %3", STRENGTH_MIN, STRENGTH_MAX, STRENGTH_STEP), category: "Object Brush")]
	protected float m_fStrength;

	[Attribute("", UIWidgets.ResourceNamePicker, "Used to set the file path to a config file", "conf", category: "Object Brush")]
	protected ResourceName m_BrushConfigPath;

	[Attribute("", UIWidgets.GraphDialog, "Used to determine the scale fall off", category: "Object Brush")]
	protected ref Curve m_ScaleFallOffCurve;

	[Attribute("", UIWidgets.GraphDialog, "Used to determine the density fall off", category: "Object Brush")]
	protected ref Curve m_DensityFallOffCurve;

	[Attribute("10", UIWidgets.SpinBox, "Sets how many sub areas will be made. Higher amount of subareas will result in a more fluid density fall off.", "1 100 1", category: "Object Brush")]
	protected int m_iDensityFallOffSubareaCount;

	[Attribute("", "Apply Density fall off to the brush", category: "Object Brush")]
	protected bool m_bDensityFallOffEnabled;

	[Attribute("", "Overwrite older brush strokes", category: "Object Brush")]
	protected bool m_bOverrideBrush;

	[Attribute(category: "Object Brush")]
	protected ref SCR_ObjectBrushArrayConfig m_ObjectsConfig;

	/*
		Category: Obstacles
	*/
	[Attribute(defvalue: "0", desc: "Objects generated by the brush will avoid static objects", category: "Obstacles")]
	protected bool m_bAvoidObjects;

	[Attribute(defvalue: "0.1", uiwidget: UIWidgets.Slider, desc: "Object avoidance detection cylinder radius", params: "0 100 0.1", category: "Obstacles")]
	protected float m_fAvoidObjectsDetectionRadius;

	[Attribute(defvalue: "100", uiwidget: UIWidgets.Slider, desc: "Object avoidance detection cylinder height", params: "0 1000 100", category: "Obstacles")]
	protected float m_fAvoidObjectsDetectionHeight;

	[Attribute(defvalue: "0", desc: "Objects generated by the brush will avoid roads", category: "Obstacles")]
	protected bool m_bAvoidRoads;

	[Attribute(defvalue: "0", desc: "Objects generated by the brush will avoid rivers", category: "Obstacles")]
	protected bool m_bAvoidRivers;

	[Attribute(defvalue: "0", desc: "Objects generated by the brush will avoid power lines", category: "Obstacles")]
	protected bool m_bAvoidPowerLines;

	[Attribute(defvalue: "0", desc: "Objects generated by the brush will avoid land", category: "Obstacles")]
	protected bool m_bAvoidLand;

	[Attribute(defvalue: "0", desc: "Objects generated by the brush will avoid ocean", category: "Obstacles")]
	protected bool m_bAvoidOcean;

	/*
		Category: Obstacles - Area
	*/
	[Attribute(defvalue: "0", desc: "Objects generated by the brush will avoid forests. Depends on Area Detection Radius", category: "Obstacles - Area")]
	protected bool m_bAvoidForests;

	[Attribute(defvalue: "0", desc: "Objects generated by the brush will avoid lakes. Depends on Area Detection Radius", category: "Obstacles - Area")]
	protected bool m_bAvoidLakes;

	[Attribute(defvalue: "100", uiwidget: UIWidgets.Slider, "Radius to detect areas (forests and lakes) around the brush's starting point for avoidance - performance setting. Zero is world-wide detection", "0 1000 100", category: "Obstacles - Area")]
	protected int m_iAreaDetectionRadius;

	#ifdef DEBUG
	protected ref array<ref Shape> m_aDebugShapes = {};
	#endif

	protected ref SCR_ObstacleDetector s_ObstacleDetector;

	protected ref array<ref ObjectBrushObjectBase> m_aObjToCreateArray = {};
	protected ref map<ref ObjectBrushObjectBase, ref EntityID> m_mCreatedObjMap = new map<ref ObjectBrushObjectBase, ref EntityID>();
	protected ref map<ref ObjectBrushObjectBase, ref EntityID> m_mActiveBrushObjects = new map<ref ObjectBrushObjectBase, ref EntityID>();

	protected bool m_bIsMouseHeldDown;

	protected ref RandomGenerator m_RandomGenerator;
	// the parameter determines the granularity of the grid. This results in the granularity being world size / 10.
	protected ref ForestGeneratorGrid m_Grid = new ForestGeneratorGrid(10);

	protected ref Shape m_BrushShape;
	protected ref array<ref Shape> m_aLineShapes = {};

	protected IEntity m_QueriedEntity;

	protected bool m_bDelete;

	protected float m_fArea;

	protected vector m_vTerrainMin;
	protected vector m_vTerrainMax;

	protected vector m_vFirstLinePoint;
	protected vector m_vSecondLinePoint;

	protected vector m_vLastMousePosition;
	protected vector m_vLastObjectCreationCentrePosition;

	protected int m_iBrushShapeColor = ARGB(255, 0, 255, 0);

	//------------------------------------------------------------------------------------------------
	protected void CreateObjects(float mouseX, float mouseY, vector traceEnd)
	{
		if (!m_API)
		{
			Print("m_API is null.", LogLevel.ERROR);
			return;
		}

		if (!m_API.IsDoingEditAction())
		{
			Print("Workbench isn't performing edit action!", LogLevel.WARNING);
			return;
		}

		if (!m_ObjectsConfig)
			return;

		m_aObjToCreateArray.Clear();

		if (m_bDensityFallOffEnabled)
		{
			float subareaRadius = m_fRadius / m_iDensityFallOffSubareaCount;
			float previousArea = 0;
			int objectGenerationAttemptsForSubarea = 0;
			int objectGenerationAttemptCurrentAmount = 0;
			int objectGenerationAttemptMaximumAmount = 0;
			float curvePoint = 0;
			float totalArea = (Math.PI * Math.Pow(m_fRadius, 2)) * HECTARE_CONVERSION_FACTOR;
			objectGenerationAttemptMaximumAmount = Math.Ceil(totalArea * m_fStrength);

			float densityFallOffMultiplier;
			ObjectBrushObjectBase obj;
			for (int i = 0; i < m_iDensityFallOffSubareaCount; ++i)
			{
				m_fArea = (Math.PI * Math.Pow(subareaRadius, 2)) * HECTARE_CONVERSION_FACTOR;
				m_fArea -= previousArea;
				previousArea += m_fArea;
				subareaRadius += m_fRadius / m_iDensityFallOffSubareaCount;

				densityFallOffMultiplier = Math3D.Curve(ECurveType.CurveProperty2D, Math.Clamp(curvePoint, 0, 1), m_DensityFallOffCurve)[1];

				objectGenerationAttemptsForSubarea = Math.Ceil(m_fArea * m_fStrength * densityFallOffMultiplier);

				for (int x = 0; x < objectGenerationAttemptsForSubarea; ++x)
				{
					if (objectGenerationAttemptCurrentAmount > objectGenerationAttemptMaximumAmount)
						break;

					obj = SelectObjectToCreate(m_ObjectsConfig.m_aObjectArray);
					if (obj)
						obj.m_iSubareaIndex = i + 1;

					objectGenerationAttemptCurrentAmount++;
				}
				curvePoint += 1 / m_iDensityFallOffSubareaCount;
			}
		}
		else
		{
			m_fArea = (Math.PI * Math.Pow(m_fRadius, 2)) * HECTARE_CONVERSION_FACTOR;
			int objectGenerationAttempts = Math.Ceil(m_fArea * m_fStrength);

			ObjectBrushObjectBase obj;
			for (int x = 0; x < objectGenerationAttempts; ++x;)
			{
				obj = SelectObjectToCreate(m_ObjectsConfig.m_aObjectArray);
				if (obj)
					obj.m_iSubareaIndex = 1;
			}
		}

		if (m_bOverrideBrush)
			DeleteObjects(traceEnd);

		IEntity entity;
		IEntitySource entSource;
		EntityID entityID

		vector angles;
		float scale;

		vector traceStart;
		vector traceEndManual;
		vector traceDir;
		vector point;
		vector transformTemp[4];

		float minDistanceFromCenter;
		float maxDistanceFromCenter;

		if (traceEnd == vector.Zero)
			m_API.TraceWorldPos(mouseX, mouseY, TraceFlags.WORLD, traceStart, traceEndManual, traceDir);
		else
			traceEndManual = traceEnd;

		m_vLastObjectCreationCentrePosition = traceEndManual;

		// area splines detected in OnMousePressEvent
		// non-area splines sphere detection here
		CreateAndInitialiseObstacleDetector();
		s_ObstacleDetector.RefreshRoadObstaclesBySphere(traceEndManual, m_fRadius);
		if (m_iAreaDetectionRadius > 0)
			s_ObstacleDetector.RefreshAreaObstaclesBySphere(traceEndManual, m_iAreaDetectionRadius);

		BaseWorld world = m_API.GetWorld();

		float distanceFromCenter;
		float distanceFromCenterInPercent;
		float scaleFallOffMultiplier;
		foreach (ObjectBrushObjectBase obj : m_aObjToCreateArray)
		{
			if (!obj.m_Prefab)
				continue;

			if (m_bDensityFallOffEnabled)
			{
				minDistanceFromCenter = (m_fRadius / m_iDensityFallOffSubareaCount) * (obj.m_iSubareaIndex - 1);
				maxDistanceFromCenter = (m_fRadius / m_iDensityFallOffSubareaCount) * obj.m_iSubareaIndex;
				point = m_RandomGenerator.GenerateRandomPointInRadius(minDistanceFromCenter, maxDistanceFromCenter, traceEndManual);

				#ifdef DEBUG
				m_aDebugShapes.Insert(CreateCircle(point, vector.Up, 0.5, ARGB(255, 0, 0, 255), 4, ShapeFlags.NOZBUFFER));
				#endif
			}
			else
			{
				point = m_RandomGenerator.GenerateRandomPointInRadius(0, m_fRadius, traceEndManual);

				#ifdef DEBUG
				m_aDebugShapes.Insert(CreateCircle(point, vector.Up, 0.5, ARGB(255, 0, 0, 255), 4, ShapeFlags.NOZBUFFER));
				#endif
			}

			if (m_Grid.IsColliding(point, obj))
				continue;

			transformTemp[3] = point;
			SCR_TerrainHelper.SnapToTerrain(transformTemp, world);
			point = transformTemp[3];

			if (s_ObstacleDetector.HasObstacle(point))
				continue;

			if (!obj.m_bOverrideRandomization)
			{
				entity = null;
				entity = m_API.CreateEntityExt(obj.m_Prefab, "", m_API.GetCurrentEntityLayerId(), null, point, vector.Zero, TraceFlags.WORLD);

				if (!entity)
				{
					Print("Failed to create entity from prefab.", LogLevel.WARNING);
					continue;
				}

				scale = entity.GetScale();
			}
			else
			{
				entity = null;
				entity = m_API.CreateEntity(obj.m_Prefab, "", m_API.GetCurrentEntityLayerId(), null, point, vector.Zero);

				if (!entity)
				{
					Print("Failed to create entity from prefab.", LogLevel.WARNING);
					continue;
				}

				if (obj.m_fMinScale == obj.m_fMaxScale)
					scale = obj.m_fMinScale;
				else
					scale = m_RandomGenerator.RandFloatXY(Math.Min(obj.m_fMinScale, obj.m_fMaxScale), Math.Max(obj.m_fMinScale, obj.m_fMaxScale));
			}

			if (obj.m_bScaleFalloff)
			{
				if (m_fRadius <= 0)
				{
					Print("Please set radius to a value higher than 0", LogLevel.WARNING);
					return;
				}

				distanceFromCenter = vector.DistanceXZ(traceEndManual, point);
				distanceFromCenterInPercent = distanceFromCenter / (m_fRadius * 0.01);
				scaleFallOffMultiplier = Math3D.Curve(ECurveType.CurveProperty2D, Math.Clamp(distanceFromCenterInPercent * 0.01, 0, 1), m_ScaleFallOffCurve)[1];

				scale *= scaleFallOffMultiplier;

				if (obj.m_bScaleFalloff && obj.m_fLowestScaleFalloffValue > obj.m_fMaxScale)
					Print("Lowest scale fall off value for " + obj.m_Prefab + " is higher than max scale value! Check parameters!", LogLevel.WARNING);

				if (scale < obj.m_fLowestScaleFalloffValue)
					scale = obj.m_fLowestScaleFalloffValue;

				if (scale > MAX_SCALE_THRESHOLD)
					scale = MAX_SCALE_THRESHOLD;
			}

			entSource = m_API.EntityToSource(entity);

			GenerateY(entSource, point);

			point[1] = point[1] + obj.m_fPrefabOffsetY;
			if (obj.m_fMinRandomVerticalOffset != 0 || obj.m_fMaxRandomVerticalOffset != 0)
				point[1] = point[1] + m_RandomGenerator.RandFloatXY(obj.m_fMinRandomVerticalOffset, obj.m_fMaxRandomVerticalOffset);

			m_API.ModifyEntityKey(entity, "coords", point.ToString(false));

			angles = vector.Zero;

			if (obj.m_bAlignToNormal)
			{
				// allow for random Yaw
				if (obj.m_bOverrideRandomization && obj.m_fRandomYawAngle > 0)
					m_API.ModifyEntityKey(entity, "angleY", m_RandomGenerator.RandFloatXY(-obj.m_fRandomYawAngle, obj.m_fRandomYawAngle).ToString());

				vector mat[4];
				entity.GetWorldTransform(mat);
				SCR_TerrainHelper.OrientToTerrain(mat, world);
				angles = Math3D.MatrixToAngles(mat);
			}
			else if (obj.m_bOverrideRandomization)
			{
				if (obj.m_fRandomPitchAngle > 0)
					angles[1] = m_RandomGenerator.RandFloatXY(-obj.m_fRandomPitchAngle, obj.m_fRandomPitchAngle);
				if (obj.m_fRandomYawAngle > 0)
					angles[0] = m_RandomGenerator.RandFloatXY(-obj.m_fRandomYawAngle, obj.m_fRandomYawAngle);
				if (obj.m_fRandomRollAngle > 0)
					angles[2] = m_RandomGenerator.RandFloatXY(-obj.m_fRandomRollAngle, obj.m_fRandomRollAngle);
			}

			m_Grid.AddEntry(obj, point);

			if (obj.m_bOverrideRandomization || obj.m_bScaleFalloff)
				m_API.ModifyEntityKey(entity, "scale", scale.ToString());

			if (angles != vector.Zero)
			{
				m_API.ModifyEntityKey(entity, "angleX", angles[1].ToString());
				m_API.ModifyEntityKey(entity, "angleY", angles[0].ToString());
				m_API.ModifyEntityKey(entity, "angleZ", angles[2].ToString());
			}

			entityID = entity.GetID();

			m_mCreatedObjMap.Insert(obj, entityID);
			m_mActiveBrushObjects.Insert(obj, entityID);
		}
	}

	//------------------------------------------------------------------------------------------------
	protected void DeleteObjects(vector vTraceEnd)
	{
		if (m_mCreatedObjMap.IsEmpty() || vTraceEnd == vector.Zero)
			return;

		map<ObjectBrushObjectBase, EntityID> ObjMapToDelete = new map<ObjectBrushObjectBase, EntityID>();
		BaseWorld world = m_API.GetWorld();

		IEntity ent;
		EntityID temp;
		vector entOrigin;
		float diff;
		foreach (ObjectBrushObjectBase obj, EntityID entID : m_mCreatedObjMap)
		{
			ent = world.FindEntityByID(entID);

			if (!ent)
			{
				ObjMapToDelete.Insert(obj, entID);
				continue;
			}

			entOrigin = ent.GetOrigin();
			diff = vector.DistanceXZ(entOrigin, vTraceEnd);

			if (diff <= m_fRadius)
			{
				if (m_bOverrideBrush)
				{
					if (!m_mActiveBrushObjects.Find(obj, temp))
						ObjMapToDelete.Insert(obj, entID);
				}
				else
				{
					ObjMapToDelete.Insert(obj, entID);
				}
			}
		}

		if (ObjMapToDelete.IsEmpty())
			return;

		foreach (ObjectBrushObjectBase obj, EntityID entID : ObjMapToDelete)
		{
			ent = world.FindEntityByID(entID);

			if (!m_API.IsDoingEditAction())
			{
				m_API.BeginEntityAction();
				m_Grid.RemoveEntry(obj);

				if (ent)
					m_API.DeleteEntity(ent);

				m_API.EndEntityAction();
			}
			else
			{
				m_Grid.RemoveEntry(obj);
				if (ent)
					m_API.DeleteEntity(ent);
			}

			m_mCreatedObjMap.Remove(obj);
		}
	}

	//------------------------------------------------------------------------------------------------
	[ButtonAttribute("Delete entities")]
	protected void DeleteEntities()
	{
		if (!m_mCreatedObjMap || m_mCreatedObjMap.IsEmpty())
			return;

		if (!m_API.IsDoingEditAction())
		{
			m_API.BeginEntityAction("Delete Entities");
			DeleteEntities();
			m_API.EndEntityAction();
		}
		else
		{
			BaseWorld world = m_API.GetWorld();
			foreach (ObjectBrushObjectBase obj, EntityID entID : m_mCreatedObjMap)
			{
				if (!world.FindEntityByID(entID))
					continue;

				m_API.DeleteEntity(world.FindEntityByID(entID));
			}
		}

		OnActivate();

		m_mCreatedObjMap.Clear();

		#ifdef DEBUG
		m_aDebugShapes.Clear();
		#endif

		return;
	}

	//------------------------------------------------------------------------------------------------
	[ButtonAttribute("Save")]
	protected void SaveConfig()
	{
		if (m_BrushConfigPath.GetPath().IsEmpty())
		{
			Print("No config file path found!", LogLevel.WARNING);
			return;
		}

		Resource holder = BaseContainerTools.CreateContainerFromInstance(m_ObjectsConfig);
		if (holder)
		{
			PrintFormat("File saved to %1", m_BrushConfigPath);
			BaseContainerTools.SaveContainer(holder.GetResource().ToBaseContainer(), m_BrushConfigPath);
			Workbench.Dialog("Config saved into file! Please restart workbench to see the effect.", "The config has saved successfully however due to workbench limitations this file cannot be loaded in the workbench. If you wish to use this file for generation you need to restart the workbench.");
		}
	}

	//------------------------------------------------------------------------------------------------
	[ButtonAttribute("Load")]
	protected void LoadConfig()
	{
		if (m_BrushConfigPath.GetPath().IsEmpty())
		{
			Print("No config file path found!", LogLevel.WARNING);
			return;
		}

		Resource holder = BaseContainerTools.LoadContainer(m_BrushConfigPath);
		if (!holder || !holder.IsValid())
			return;

		BaseContainer cont = holder.GetResource().ToBaseContainer();
		if (!cont)
			return;

		if (cont.GetClassName() != "SCR_ObjectBrushArrayConfig")
		{
			Print(string.Format("Config '%1' is of type '%2', must be 'SCR_ObjectBrushArrayConfig'!", m_BrushConfigPath, cont.GetClassName()), LogLevel.ERROR);
			return;
		}

		SCR_ObjectBrushArrayConfig arrayConfig = SCR_ObjectBrushArrayConfig.Cast(BaseContainerTools.CreateInstanceFromContainer(cont));

		if (!arrayConfig || !arrayConfig.m_aObjectArray)
			return;

		if (!m_ObjectsConfig)
			m_ObjectsConfig = new SCR_ObjectBrushArrayConfig();

		m_ObjectsConfig.m_aObjectArray.Clear();

		foreach (ObjectBrushObjectBase obj : arrayConfig.m_aObjectArray)
		{
			m_ObjectsConfig.m_aObjectArray.Insert(obj);
		}

		ObjectBrushTool.UpdatePropertyPanel();
	}

	//------------------------------------------------------------------------------------------------
	override void OnMousePressEvent(float x, float y, WETMouseButtonFlag buttons)
	{
		vector traceStart, traceEnd, traceDir;
		m_API.TraceWorldPos(x, y, TraceFlags.WORLD, traceStart, traceEnd, traceDir);

		m_bIsMouseHeldDown = true;
		m_RandomGenerator = new RandomGenerator();

		BaseWorld world = m_API.GetWorld();
		foreach (ObjectBrushObjectBase objBase, EntityID entID : m_mCreatedObjMap)
		{
			if (world.FindEntityByID(entID))
				continue;

			m_Grid.RemoveEntry(objBase);
			m_mCreatedObjMap.Remove(objBase);
		}

		if (buttons != WETMouseButtonFlag.LEFT)
			return;

		// non-area splines sphere detected in CreateObjects
		// area splines detected here
		if ((m_bAvoidForests || m_bAvoidLakes) && m_iAreaDetectionRadius == 0)
		{
			CreateAndInitialiseObstacleDetector();
			s_ObstacleDetector.RefreshAreaObstaclesByWorld();
		}

		if (!GetModifierKeyState(ModifierKey.ALT))
		{
			if (!m_API.IsDoingEditAction())
				m_API.BeginEntityAction("Brush Action");

			m_mActiveBrushObjects.Clear();

			if (m_bDelete)
				DeleteObjects(traceEnd);
			else
				CreateObjects(x, y, traceEnd);
		}
		else // GetModifierKeyState(ModifierKey.ALT)
		{
			if (m_vFirstLinePoint == vector.Zero)
			{
				m_vFirstLinePoint = traceEnd;
				return;
			}

			if (!m_API.IsDoingEditAction())
				m_API.BeginEntityAction("Brush Line Action");

			m_mActiveBrushObjects.Clear();

			m_vSecondLinePoint = traceEnd;

			#ifdef DEBUG
			vector p[2];
			p[0] = m_vFirstLinePoint;
			p[1] = m_vSecondLinePoint;
			m_aDebugShapes.Insert(Shape.CreateLines(ARGB(255, 255, 0, 0), ShapeFlags.NOZBUFFER, p, 2));
			#endif

			float dist = vector.Distance(m_vFirstLinePoint, m_vSecondLinePoint);
			vector dir = vector.Direction(m_vFirstLinePoint, m_vSecondLinePoint);
			dir.Normalize();

			vector point = m_vFirstLinePoint;

			#ifdef DEBUG
			m_aDebugShapes.Insert(CreateCircle(m_vFirstLinePoint, vector.Up, 2, ARGB(255, 0, 255, 0), 4, ShapeFlags.NOZBUFFER));
			m_aDebugShapes.Insert(CreateCircle(m_vSecondLinePoint, vector.Up, 2, ARGB(255, 0, 255, 0), 4, ShapeFlags.NOZBUFFER));
			#endif

			if (m_bDelete)
				DeleteObjects(point);
			else
				CreateObjects(x, y, point);

			while (dist - m_fRadius / 2 > 0)
			{
				point = point + dir * (m_fRadius / 2);

				#ifdef DEBUG
				m_aDebugShapes.Insert(CreateCircle(point, vector.Up, 1, ARGB(255, 0, 255, 0), 12, ShapeFlags.NOZBUFFER));
				#endif

				dist -= m_fRadius / 2;

				if (m_bDelete)
					DeleteObjects(point);
				else
					CreateObjects(x, y, point);
			}

			if (dist > m_fRadius / 4)
			{
				#ifdef DEBUG
				m_aDebugShapes.Insert(CreateCircle(m_vSecondLinePoint, vector.Up, 1, ARGB(255, 0, 255, 0), 12, ShapeFlags.NOZBUFFER));
				#endif

				if (m_bDelete)
					DeleteObjects(m_vSecondLinePoint);
				else
					CreateObjects(x, y, m_vSecondLinePoint);
			}

			m_vFirstLinePoint = vector.Zero;
			m_vSecondLinePoint = vector.Zero;

			m_API.EndEntityAction();
		}
	}

	//------------------------------------------------------------------------------------------------
	override void OnMouseReleaseEvent(float x, float y, WETMouseButtonFlag buttons)
	{
		m_bIsMouseHeldDown = false;
		m_vLastObjectCreationCentrePosition = vector.Zero;

		if (m_API.IsDoingEditAction())
			m_API.EndEntityAction();
	}

	//------------------------------------------------------------------------------------------------
	override void OnMouseMoveEvent(float x, float y)
	{
		m_aLineShapes.Clear();

		vector traceStart, traceEnd, traceDir;
		m_API.TraceWorldPos(x, y, TraceFlags.WORLD, traceStart, traceEnd, traceDir);

		m_vLastMousePosition = traceEnd;

		if (m_bDelete)
			m_iBrushShapeColor = ARGB(255,255,0,0);
		else
			m_iBrushShapeColor = ARGB(255,0,255,0);

		m_BrushShape = CreateCircle(traceEnd, vector.Up, m_fRadius, m_iBrushShapeColor, 50, ShapeFlags.NOZBUFFER);

		if (m_vFirstLinePoint != vector.Zero)
		{
			vector points[2];
			points[0] = m_vFirstLinePoint;
			points[1] = traceEnd;
			m_aLineShapes.Insert(Shape.CreateLines(m_iBrushShapeColor, ShapeFlags.NOZBUFFER, points, 2));
			m_aLineShapes.Insert(CreateCircle(m_vFirstLinePoint, vector.Up, m_fRadius, m_iBrushShapeColor, 50, ShapeFlags.NOZBUFFER));
		}

		if (!m_bIsMouseHeldDown)
			return;

		if (m_bDelete)
			DeleteObjects(traceEnd);
		else if (vector.DistanceXZ(m_vLastMousePosition, m_vLastObjectCreationCentrePosition) >= STRENGTH_RELATIVE_RADIUS_DISTANCE_TO_CREATE * m_fRadius)
			CreateObjects(x, y, traceEnd);
	}

	//------------------------------------------------------------------------------------------------
	override void OnWheelEvent(int delta)
	{
		// adjusts m_fRadius value using a CTRL + Scrollwheel keybind
		if (GetModifierKeyState(ModifierKey.CONTROL))
		{
			m_fRadius = AdjustValueUsingScrollwheel(delta, m_fRadius, RADIUS_STEP, RADIUS_MAX, RADIUS_MIN);
			m_BrushShape = CreateCircle(m_vLastMousePosition, vector.Up, m_fRadius, m_iBrushShapeColor, 50, ShapeFlags.NOZBUFFER);
			ObjectBrushTool.UpdatePropertyPanel();
		}

		// adjusts m_fStrength value using a SHIFT + Scrollwheel keybind
		if (GetModifierKeyState(ModifierKey.SHIFT))
		{
			m_fStrength = AdjustValueUsingScrollwheel(delta, m_fStrength, STRENGTH_STEP, STRENGTH_MAX, STRENGTH_MIN);
			ObjectBrushTool.UpdatePropertyPanel();
		}
	}

	//------------------------------------------------------------------------------------------------
	override void OnKeyPressEvent(KeyCode key, bool isAutoRepeat)
	{
		if (key == KeyCode.KC_SPACE)
		{
			m_bDelete = true;
			m_iBrushShapeColor = ARGB(255, 255, 0, 0);
			m_BrushShape = CreateCircle(m_vLastMousePosition, vector.Up, m_fRadius, m_iBrushShapeColor, 50, ShapeFlags.NOZBUFFER);
		}
	}

	//------------------------------------------------------------------------------------------------
	override void OnKeyReleaseEvent(KeyCode key, bool isAutoRepeat)
	{
		if (key == KeyCode.KC_SPACE)
		{
			m_bDelete = false;
			m_iBrushShapeColor = ARGB(255, 0, 255, 0);
			m_BrushShape = CreateCircle(m_vLastMousePosition, vector.Up, m_fRadius, m_iBrushShapeColor, 50, ShapeFlags.NOZBUFFER);
		}
	}

	//------------------------------------------------------------------------------------------------
	override void OnDeActivate()
	{
		m_BrushShape = null;
	}

	//------------------------------------------------------------------------------------------------
	override void OnActivate()
	{
		m_Grid.Clear();

		if (!m_API.GetWorld())
			return;

		m_API.GetWorld().GetBoundBox(m_vTerrainMin, m_vTerrainMax);

		float x, z;
		x = m_vTerrainMax[0] - m_vTerrainMin[0];
		z = m_vTerrainMax[2] - m_vTerrainMin[2];

		m_Grid.Resize(x, z);
	}

	//------------------------------------------------------------------------------------------------
	ObjectBrushObjectBase SelectObjectToCreate(array<ref ObjectBrushObjectBase> objects)
	{
		if (objects.IsEmpty())
			return null;

		ObjectBrushObjectBase selectedObject = null;
		int objTypeIdx = -1;
		float objProba, probaSum, weightTotal;

		foreach (ObjectBrushObjectBase obj : objects)
		{
			if (obj.m_fWeight > 0)
				weightTotal += obj.m_fWeight;
		}

		if (weightTotal <= 0)
			return null;

		objProba = m_RandomGenerator.RandFloatXY(0, weightTotal);

		foreach (ObjectBrushObjectBase obj : objects)
		{
			if (obj.m_fWeight > 0)
				probaSum += obj.m_fWeight;

			if (objProba < probaSum)
			{
				selectedObject = ObjectBrushObjectBase.Cast(obj.Copy());
				break;
			}
		}

		if (!selectedObject)
			return null;

		m_aObjToCreateArray.Insert(selectedObject);

		return selectedObject;
	}

	//------------------------------------------------------------------------------------------------
	void GenerateY(notnull IEntitySource entSource, inout vector point)
	{
		int flags;
		if (!entSource.Get("Flags", flags))
			return;

		if (!(flags & EntityFlags.RELATIVE_Y))
		{
			float y;
			if (m_API.TryGetTerrainSurfaceY(point[0], point[2], y))
				point[1] = y;
		}
		else
		{
			point[1] = 0;
		}
	}

	//------------------------------------------------------------------------------------------------
	protected float AdjustValueUsingScrollwheel(float delta, float attributeToEdit, float step, float max, float min)
	{
		// delta returns multiples of 120 I am converting into a more useable value of multiples of 1
		if ((attributeToEdit + (delta / 120) * step) > max || (attributeToEdit + (delta / 120) * step) < min)
			return attributeToEdit;

		return attributeToEdit + (delta / 120) * step;
	}

	//------------------------------------------------------------------------------------------------
	protected void CreateAndInitialiseObstacleDetector()
	{
		if (s_ObstacleDetector && s_ObstacleDetector.IsValid())
			return;

		s_ObstacleDetector = new SCR_ObstacleDetector(m_API);

		s_ObstacleDetector.SetAvoidObjects(m_bAvoidObjects);
		s_ObstacleDetector.SetAvoidObjectsDetectionHeight(m_fAvoidObjectsDetectionHeight);
		s_ObstacleDetector.SetAvoidObjectsDetectionRadius(m_fAvoidObjectsDetectionRadius);
		s_ObstacleDetector.SetAvoidRoads(m_bAvoidRoads);
		s_ObstacleDetector.SetAvoidRivers(m_bAvoidRivers);
		s_ObstacleDetector.SetAvoidPowerLines(m_bAvoidPowerLines);
		s_ObstacleDetector.SetAvoidForests(m_bAvoidForests);
		s_ObstacleDetector.SetAvoidLakes(m_bAvoidLakes);
		s_ObstacleDetector.SetAvoidLand(m_bAvoidLand);
		s_ObstacleDetector.SetAvoidOcean(m_bAvoidOcean);
	}
};
#endif
