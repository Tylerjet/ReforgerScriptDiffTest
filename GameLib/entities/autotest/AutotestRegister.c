// Script File


enum MeasurementType
{
	HeatMap,
	GraphLine,
	GraphBar,
	HTML,
	File,
	Gallery
};

//! Implementation of single measurement result file (dont forget to delete it after you are done or use strong ref)
class MeasurementFile
{	
	///////////////////////////////////////////////////////////////////////
	// VARIABLES
	private AutotestRegister m_parent;	//< Register this file is made from
	private string m_filePath;			//< Path to physical file of this measurement
	private FileHandle m_handle;		//< Handle to physical file
	private MeasurementType m_type;		//< What type of measurement visualization this file will generate
	private string m_graphHeader;		//< Table header for graph type measurements
	private bool m_containsNoData;		//< Does this file contain any data or is it plain autotest header only (first line only)
	
	
	
	///////////////////////////////////////////////////////////////////////
	// PUBLIC FUNCTIONS
	//! Constructor which checks in case of appending if file exists already and if so it checks if physical file 
	//		contains anything more than only autotest header (sets m_containsNoData)
	void MeasurementFile(AutotestRegister parent, string path, FileMode mode, MeasurementType type)
	{
		m_type 		= type;
		m_parent 	= parent;
		m_filePath 	= path;
		
		if(mode == FileMode.APPEND && FileIO.FileExist(path))
		{
			m_handle = FileIO.OpenFile(path, FileMode.READ);
			
			int lineCount = 0;
			
			string line;
			while(m_handle.FGets(line) > 0)
			{
				lineCount++;
				if(lineCount > 1)
					break;
			}
			m_containsNoData = lineCount < 2;
			m_handle.CloseFile();
		}
		else
			m_containsNoData = true;
		
		m_handle = FileIO.OpenFile(m_filePath, mode);
		
	}
	//! Destructor - in case that there is a file opened, closes it. Also appends prepared graph header if it makes sense
	void ~MeasurementFile()
	{
		if(IsChart() && m_containsNoData && m_graphHeader.Length() > 0)
			m_handle.FPrintln(m_graphHeader);	
		m_handle.CloseFile();
	}
	
	//! Was file open valid, can we write inside?
	bool IsValid()
	{
		return m_handle != 0;
	}
	
	//! Returns full path to this measurement file
	string GetFilePath() { return m_filePath; }
	
	//! If data type is graph we should set its data header
	//		This muse be called before first AddData or generic header gets generated
	void SetGraphHeader(string header)
	{
		if(!m_handle)
			return;
		m_graphHeader = header;
	}
	
	//! Adds single line into this measurement FileMode
	//		With first data we append into file containing graph it automatically appends
	//		either set in SetGraphHeader or ig gets autogenerated
	void AddData(string line)
	{
		if(!m_handle)
			return;
		if(IsChart() && m_containsNoData)
		{
			if(m_graphHeader.Length() > 0)
				m_handle.FPrintln(m_graphHeader);	
			else
			{
				array<string> arr = new array<string>();
				line.Split(",", arr, true);
				
				string artificialHeader;
				for(int i = 0; i < arr.Count(); ++i)
				{
					if(i != 0)
						artificialHeader = string.Format("%1,%2", artificialHeader, i);
					else
						artificialHeader = string.Format("%1", i);
				}
				m_handle.FPrintln(artificialHeader);
			}
		}
		
		m_containsNoData = false;
		m_handle.FPrintln(line);
	}
	
	//! Returns true when type of this file is some type of graph (not heatmap)
	//		It is used internally to find out if we should append graph header in this file.
	bool IsChart()
	{
		return m_type == MeasurementType.GraphLine || m_type == MeasurementType.GraphBar;
	}
	
	
	///////////////////////////////////////////////////////////////////////
	// UNUSUAL
	
	//! This function would normally be private and callable only from inside AutotestRegister
	//		Ignore it or you may breake the system
	void AddHeader(string measurementTitle)
	{
		if(!m_handle || !m_containsNoData)
			return;
		
		if(m_type == MeasurementType.HeatMap)
		{
			m_handle.FPrintln(string.Format("%1;%2;heatmap", m_parent.GetAutotestPageName(), measurementTitle));
			m_handle.FPrintln("x,y,FPS");
		}
		else if(m_type == MeasurementType.GraphLine)
			m_handle.FPrintln(string.Format("%1;%2;chart;line", m_parent.GetAutotestPageName(), measurementTitle));
		else if(m_type == MeasurementType.GraphBar)
			m_handle.FPrintln(string.Format("%1;%2+chart;bar", m_parent.GetAutotestPageName(), measurementTitle));
		else if(m_type == MeasurementType.HTML)
			m_handle.FPrintln(string.Format("%1;%2;html", m_parent.GetAutotestPageName(), measurementTitle));
		else if(m_type == MeasurementType.File)
			m_handle.FPrintln(string.Format("%1;%2;file", m_parent.GetAutotestPageName(), measurementTitle));
		else if(m_type == MeasurementType.Gallery)
			m_handle.FPrintln(string.Format("%1;%2;gallery", m_parent.GetAutotestPageName(), measurementTitle));
	}
}


//! This class should be created once per autotest / autotest-entity
class AutotestRegister
{
	///////////////////////////////////////////////////////////////////////
	// VARIABLES
	protected string m_worldFileFolder;
	protected string m_autotestPageName;
	//! This number serves to keep track of index of test we are running (usefull when we have multiple world files in single autotest)
	protected int m_testIndex = 0;

	
		
	///////////////////////////////////////////////////////////////////////
	// PUBLIC FUNCTIONS
	
	//! Initializes register with pageName which is then used for all child result files as page name
	//		This also handles persistent autotest indexing m_testIndex
	void Init(string pageName)
	{
		m_autotestPageName = pageName;
		
		m_worldFileFolder = "$profile:"; 
		
		string mutliTestFile = string.Format("%1/%2", m_worldFileFolder, "last_test_index.log");
		FileHandle tmp;
		if(FileIO.FileExist(mutliTestFile))
		{
			tmp = FileIO.OpenFile(mutliTestFile, FileMode.READ);
			string line;
			tmp.FGets(line);
			m_testIndex = line.ToInt() + 1;
			tmp.CloseFile();
		}
		
		tmp = FileIO.OpenFile(mutliTestFile, FileMode.WRITE);
		if (tmp)
		{
			tmp.FPrintln(string.Format("%1", m_testIndex));
			tmp.CloseFile();
		}
	}
	
	//! Returns page name for this autotest
	string GetAutotestPageName() { return m_autotestPageName; }
	
	//! Returns path to world file of this autotest
	string GetWorldFileFolderPath() { return m_worldFileFolder; }
	
	//! Returns index of this autotest (if we have multiple entities, or world files in single autotest we can track
	//		if it is first time (first world) when autotest runs or we are in the middle of multistage/multiworld autotest
	//		in such case this will return >0 if it is first it will return 0. This is usefull when you want to for example
	//		delete some temporary files before running autotest measurements
	int GetTestIndex() 
	{
		return m_testIndex;
	}
	
	//! Checks if file with given measurement name exists
	bool DoesMeasurementExist(string name)
	{
		return FileIO.FileExist(CreateMeasurementFilePath(name));
	}
		
	//! This opens new measurement file for adding data to it. By default it will delete old results if there are any.
	//		If you set false into overwriteExisting it will try to open existing measurement file and append to PSVrTrackingQualityEnum
	//		In case there is none it will simply create new one and prepare autotest header into it so we can always AddData right away
	//	
	//		!!! Dont forget to store into ref !!!
	MeasurementFile OpenMeasurementFile(string name, string measurementTitle, MeasurementType type, bool overwriteExisting = true)
	{
		MeasurementFile ret;
		
		string measurementFilePath = CreateMeasurementFilePath(name);
		if(overwriteExisting || !FileIO.FileExist(measurementFilePath))
		{
			ret = new MeasurementFile(this, measurementFilePath, FileMode.WRITE, type);
			ret.AddHeader(measurementTitle);
		}
		else
		{
			ret = new MeasurementFile(this, measurementFilePath, FileMode.APPEND, type);
		}
		
		return ret;
	}
	
	//! If this is called it will automatically prepare "measurement file" which will upload console.log into 
	//		result page (under name "console.log" - link to it is also put at the end of results)
	void UploadLogFileWithResults()
	{
		string logFilePath = string.Format("%1/console.log", m_worldFileFolder);
		if(!FileIO.FileExist(logFilePath))
		{
			FileHandle logFileHandle = FileIO.OpenFile(logFilePath, FileMode.WRITE);
			logFileHandle.FPrintln("Missing log file");
			logFileHandle.CloseFile();
		}
		
		ref MeasurementFile logFileUploader = OpenMeasurementFile("zzz_console_log_upload", "Console log", MeasurementType.File);
		logFileUploader.AddData(logFilePath);
	}
	
	//! This allows you to save your own data which you can later read even in next test run (after exe finished)
	void SavePersistentData(string name, string data)
	{
		FileHandle tmp = FileIO.OpenFile(CreatePersistentFilePath(name), FileMode.WRITE);
		tmp.FPrintln(data);
		tmp.CloseFile();
	}
	//! Returns previously stored data (by calling SavePersistentData) under given name (works even between exe runs)
	string LoadPersistentData(string name)
	{
		FileHandle tmp = FileIO.OpenFile(CreatePersistentFilePath(name), FileMode.READ);
		
		string data;
		tmp.FGets(data);
		
		tmp.CloseFile();
		return data;
	}
	
	//! Returns number of lines givenmeasurement file has inside 
	//		dont forget that charts has +1 than you would probably expect because of chart header)
	int GetNumberOfDataLines(string measurementName)
	{
		FileHandle tmp = FileIO.OpenFile(CreateMeasurementFilePath(measurementName), FileMode.READ);
		
		int count = -1;
		
		string lineContent;
		while(tmp.FGets(lineContent) > 0)
			count++;
		
		tmp.CloseFile();
		return count;
	}
	
	//! Returns number of .ent files in current autotest folder
	int GetNumberOfWorldFiles()
	{
		array<string> files = {};
		System.FindFiles(files.Insert, m_worldFileFolder, ".ent");
		return files.Count();
	}
	
	///////////////////////////////////////////////////////////////////////
	// PRIVATE FUNCTIONS
	private string CreatePersistentFilePath(string name)
	{
		return string.Format("%1/%2", m_worldFileFolder, name);
	}
	private string CreateMeasurementFilePath(string name)
	{
		return string.Format("%1/%2.txt", m_worldFileFolder, name);
	}
}